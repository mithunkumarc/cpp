Race condition: 
        A race condition is a situation, in which the result of an operation depends on the interleaving of certain individual operations.

Data race: 
        A data race is a situation, in which at least two threads access a shared variable at the same time. At least on thread tries to modify the variable.

A race condition is per se not bad. A race condition can be the reason for a data race. 
In contrary, a data race is an undefined behaviour. 
Therefore, all reasoning about your program makes no sense anymore.

#### In the single threaded case, all is fine.

                #include <iostream>

                struct Account{
                    int balance{100};
                };

                void transerMoney(int amount, Account& from, Account& to){
                    if(from.balance >= amount){
                        from.balance = from.balance - amount;
                        to.balance = to.balance + amount;
                    }
                }


                int main(){
                    std::cout << std::endl;

                    Account account1;
                    Account account2;

                    transerMoney(50, account1, account2);
                    transerMoney(130, account2, account1);

                    std::cout << "account1.balance : " << account1.balance << std::endl;
                    std::cout << "account2.balance : " << account2.balance << std::endl;

                    std::cout << std::endl;

                }
                
                output  :
                
                account1.balance : 180
                account2.balance : 20


#### multithreaded :  we have a data race and a race condition.


        #include <functional>
        #include <iostream>
        #include <thread>

        struct Account{
            int balance{100};
        };

        void transferMoney(int amount, Account& from, Account& to){
            using namespace std::chrono_literals;
            std::cout << "requesting amount : " << amount << std::endl;
            if(from.balance >= amount){        
                from.balance = from.balance - amount;
                std::this_thread::sleep_for(1ns);
                std::cout << "from.balance : " << from.balance << ", to.balance : " << to.balance << std::endl;
                to.balance = to.balance + amount;
                std::cout << "from.balance : " << from.balance << ", to.balance : " << to.balance << std::endl;
            }
        }

        int main(){
            std::cout << std::endl;
            Account account1;
            Account account2;
            std::thread thr1(transferMoney, 50, std::ref(account1), std::ref(account2));    
            std::thread thr2(transferMoney, 130, std::ref(account1), std::ref(account2));
            thr1.join();
            thr2.join();
            std::cout << "account1.balance : " << account1.balance << std::endl;
            std::cout << "account2.balance : " << account2.balance << std::endl;
            std::cout << std::endl;
        }

        output :                 
        mithun@linux:~/Documents/cpp$ g++ -std=c++17 Test.cpp -pthread
        mithun@linux:~/Documents/cpp$ ./a.out

        requesting amount : 50
        requesting amount : 130
        from.balance : 50, to.balance : 100
        from.balance : 50, to.balance : 150
        account1.balance : 50
        account2.balance : 150
        
        expected : 
        account1.balance : 180
        account2.balance : 20
        
        
### Solving the data race using atomic variable.        

http://www.modernescpp.com/index.php/race-condition-versus-data-race
